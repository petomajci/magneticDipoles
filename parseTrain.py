#!/usr/bin/python2.7

#import modules
from sys import argv, exit, version
from os import system, path
try:
    from optparse import OptionParser as OP
except:
    print "Optparse not installed or not in python path. I give up..."
    exit(10)
try:
    from numpy import array,zeros, sin, cos, sqrt, pi, arccos, modf, linspace
except:
    print "Numpy not installed or not in python path. I give up..."
    exit(10)
from string import split, strip, join,lower
from math import exp

def read_xyz(file,offset=None):
    oldC="aaa"
    line=file.readline() #read fist line: number of atoms and optional comment
    while len(line)>0:
        junk=line.split(",")
        if junk[1]!=oldC:
            if oldC!="aaa":
                trainF.close()
            trainF=safeopen("./TTT/"+junk[1]+".xyz.train",'w')
            oldC=junk[1]
            
        trainF.write(line)
        line=file.readline()
    trainF.close()
    
def safeopen(infile,mode):
    '''Open safetely a file
    '''
    try:
        file=open(infile,mode)
    except IOError:
        file=None
    return file

def filecheck(file):
    ''' Check if infile exists
    '''
    if path.isfile(file) == 0:
        found=False
    else:
        found=True
    return found

def backup_file(file):
    '''check if file exists. if not open file
    for writing, otherwhise backup the old one in
    #infile_x# with x progressive number
    '''
    tmpvar=file
    count=0
    while 1:
        found=filecheck(file)
        if found:
            count+=1
            file=tmpvar+'_bak-'+str(count)
        else:
            break
    if file !=tmpvar:
        system('mv '+tmpvar+' '+file)

def parsecmd():
    description="Calculate distances, angles, torsions and quota in periodic or\
 non-periodic molecular structures.\n\
See documentation for further information."
    usage="usage: %prog [options] input_file"
    #updtate this when new formats are added
    
    list_of_formats="XYZ/XMOL, TINKER XYZ/ARC"
    #parse command line
    parser=OP(version='%prog 1.1',description=description,usage=usage)

    parser.add_option('-c','--credits',dest='credits',action='store_true',
                     default=False,help='display credits')
    parser.add_option('-f','--format',dest='fformat', default="arc",
                      help='specify the format of the input structure, [default: %default]')
    parser.add_option('-e','--filedata',dest='filedata',nargs=1,
                      help='specify that input file is setup file')
    parser.add_option('-d','--distance',dest='distance',nargs=2,type='int',
                     help='require a distance calculation on the specified couple of atoms')
    parser.add_option('-a','--angle',dest='angle',nargs=3,type='int',
                     help='require angle calculation on the specified three atoms')
    parser.add_option('-t','--torsion',dest='torsion',nargs=5,type='int',
                     help='require torsions calculation on the specified four atoms and periodicity (i.e. 360 deg)')
    parser.add_option('-u','--unitcell',dest='periodicity',nargs=6,type='float',
                     help='define periodic unit cell (a,b,c in angstrom; alpha,beta,gamma in degrees)')
    parser.add_option('-l','--listformats',dest='listformats',action='store_true',
                     default=False, help='list the available formats')
    (options, args) = parser.parse_args(argv[1:])
    
    #manage parse errors
    if options.credits: #display credits and quit
       credits="\n**********************************\n\
    Andrea Minoia\n\
    Contacts: minoiaa_at_gmail.com\n\
\n*********************************\n"
       print credits
       exit()
       
    if len(args)==0 and not options.listformats:   #arguments missing
        parser.exit(parser.print_help())
    
    if len(args)>1: #check if more than one argument (NOT OPTION) has been parsed
        parser.error('You have given me more than one argument '+str(args)+'... dunno what to do...\n')
    
    if options.listformats:
        print "\nList of available formats: "+list_of_formats+"\n"
        exit(0)
    
    else:
       pass
    return options,args

def read_filedata(file):
    ''' get data from file generated by get_geomtasks_from_vmd
    '''
    dists=[]
    angs=[]
    tors=[]
    outfiles=[]
    tasklist=[]
    while 1:
        junk=[]    
        line=file.readline()
        if len(line)==0:
            break
        if split(line)[0] == "#":
            pass
        else:
            line=split(line[:-1])
            if len(line)==2: #two atoms have been found
                junk.append(int(line[0]))
                junk.append(int(line[1]))
                dists.append(junk)
            elif len(line)==3: #three atoms have been found
                junk.append(int(line[0]))
                junk.append(int(line[1]))
                junk.append(int(line[2]))
                angs.append(junk)
            elif len(line)==4 or len(line)==5: #four atoms have been found
                junk.append(int(line[0]))
                junk.append(int(line[1]))
                junk.append(int(line[2]))
                junk.append(int(line[3]))
                if len(line) == 5: #periodicity
                    junk.append(int(line[4]))
                else:
                    junk.append(360)
                tors.append(junk)
            else:
                print"\nUnusual line read... I quit."
                file.close()
                exit(10)
    if len(dists)==0:
        tasklist.append(None)
        outfiles.append(None)
    else:
        outfiles.append('dists.dat')
        tasklist.append(dists)            

    if len(angs)==0:
        outfiles.append(None)
        tasklist.append(None)
    else:
        tasklist.append(angs)            
        outfiles.append('angs.dat')

    if len(tors)==0:
        outfiles.append(None)
        tasklist.append(None)
    else:
        tasklist.append(tors)
        outfiles.append('tors.dat')
    return tasklist,outfiles

def GetNeigborsCount(atom,at_symbols, coordinates, neighbors):
    counts =  { "H":0, "C":0, "N":0, "F":0, "O":0, "all":0 } 
    for i in neighbors[atom]:
        counts[at_symbols[i]]+=1
        counts["all"]+=1

    print "AAA", atom,
    for f in counts:
        print f,counts[f],
    print ""

def SmoothGaussian(r1, r2, beta=100):
    #return 1*(abs(r1-r2)<0.01)
    x = beta * (r1-r2)
    #print beta,x
    return exp(-x**2)

def GetNeigborsDistances(atom,at_symbols, coordinates, neighbors):
    Nbins = 40
    Range = linspace(0.9, 1.6, Nbins)
    #print Range
    element =  { "H":0, "C":1, "N":2, "F":3, "O":4, "all":5 }
    rev_element =  { 0:"H", 1:"C", 2:"N", 3:"F", 4:"O", 5:"all" }
    
    N = 6
    counts = [[0] * Nbins for i in range(N)]
    
    for i in neighbors[atom]:
        dd = getdist(coordinates[atom],coordinates[i])
        for n in range(Nbins):
            val = SmoothGaussian(dd,Range[n])
            counts[element[at_symbols[i]]][n] += val
            counts[5][n] += val

    for f in range(N):
        print "CCC", atom, rev_element[f],
        for n in range(Nbins):
            print "%.1f" % counts[f][n],
        print ""

def GetNeigborsAngles(atom1,atom2,at_symbols, coordinates, neighbors):
    Nbins = 40
    Range = linspace(40, 180, Nbins)
    #print Range
    element =  { "H":0, "C":1, "N":2, "F":3, "O":4, "all":5 }
    rev_element =  { 0:"H", 1:"C", 2:"N", 3:"F", 4:"O", 5:"all" }
    
    N = 6
    counts = [[0] * Nbins for i in range(N)]
    
    for i in neighbors[atom2]:
		if i!=atom1:
			dd = getangle(coordinates[atom1],coordinates[atom2],coordinates[i])
			for n in range(Nbins):
				val = SmoothGaussian(dd,Range[n], beta=0.5)
				counts[element[at_symbols[i]]][n] += val
				counts[5][n] += val

    for f in range(N):
        print "DDD", atom1, atom2, rev_element[f],
        for n in range(Nbins):
            print "%.1f" % counts[f][n],
        print ""

def GetNeigborsTorsions(atom1,atom2,at_symbols, coordinates, neighbors):
    Nbins = 40
    Range = linspace(0, 180, Nbins)
    #print Range
    element =  { "H":0, "C":1, "N":2, "F":3, "O":4, "all":5 }
    rev_element =  { 0:"H", 1:"C", 2:"N", 3:"F", 4:"O", 5:"all" }
    
    N = 6
    counts = [[0] * Nbins for i in range(N)]
    
    for i in neighbors[atom2]:
		if i!=atom1:
			for j in neighbors[i]:
				if j!=atom2:
					dd = abs(gettors(coordinates[atom1],coordinates[atom2],coordinates[i],coordinates[j]))
					#print atom1, atom2, i, j, dd
					for n in range(Nbins):
						val = SmoothGaussian(dd,Range[n], beta=0.25)
						counts[element[at_symbols[j]]][n] += val
						counts[5][n] += val

    for f in range(N):
        print "EEE", atom1, atom2, rev_element[f],
        for n in range(Nbins):
            print "%.1f" % counts[f][n],
        print ""


def Get2ndLevelNeigborsCount(atom,at_symbols, coordinates, neighbors):
    counts =  { "H":0, "C":0, "N":0, "F":0, "O":0, "all":0 }
    for i in neighbors[atom]:
        for j in neighbors[i]:
            if j!=atom:
                counts[at_symbols[j]]+=1
                counts["all"]+=1

    print "BBB", atom,
    for f in counts:
        print f,counts[f],
    print ""


def run(infile,tasklist,fformat,outfiles,pbc=None):
    '''run calculation
    '''
    structfile=safeopen(infile,'r')
    if structfile == None: #if file not found, print error and quit
        print "\nWhooooaaaa! Cannot file "+infile+"... I'm out of here\n"
        exit(10)    
    offset=None
    at1=array([0,0,0],float)
    at2=array([0,0,0],float)
    at3=array([0,0,0],float)
    at4=array([0,0,0],float)
    F_DISTS=None
    F_ANGS=None
    F_TORS=None

    #main loop
    while 1:
        #get format file structure
        if lower(fformat) == "arc":
            retdata=read_arc(structfile,offset)
        elif lower(fformat) == "xyz":
            retdata=read_xyz(structfile,offset)
            exit(9)
        else:
            pass
                
        if retdata=="EOF":
            break
        else:
            coordinates=retdata[0]  #always in 1st position if not EOF
            offset=retdata[1]       #always in 2nd position if not EOF
            at_symbols=retdata[2]

        neighbors = [dict() for x in range(len(coordinates))]

        # get all bonds
        #print "LLL",len(coordinates)
        for i in range(len(coordinates)-1):
            for j in range(i+1,len(coordinates)):
                dd = getdist(coordinates[i],coordinates[j])
                if dd < covalentR[at_symbols[i]]+covalentR[at_symbols[j]]:
                        #print "KKK:   ",i,j,covalentR[at_symbols[i]]+covalentR[at_symbols[j]]
                        neighbors[i][j] = dd
                        neighbors[j][i] = dd
        # Print all neighbors
        for i in range(len(coordinates)):
            for j in neighbors[i]:
                print "BOND",i,j, at_symbols[i],at_symbols[j], len(neighbors[i])-1,len(neighbors[j])-1,neighbors[i][j]
                #for k in neighbors[i]:
                #    if k!=j:
                #        print

        # Print angles:
        for i in range(len(coordinates)):
            for j in neighbors[i]:
                for k in neighbors[i]:
                    if j!=k: print "ANGLE",j,i,k, at_symbols[j],at_symbols[i],at_symbols[k], getangle(coordinates[j],coordinates[i],coordinates[k])
        
        #Print dihedrals
        for i in range(len(coordinates)):
            for j in neighbors[i]:
                if i<j:  # get dihedrals for i-j bond
                    for k in neighbors[i]:
                        if k!=j:
                            for l in neighbors[j]:
                                if l!=i:
                                    print "TORS",k,i,j,l, at_symbols[k],at_symbols[i],at_symbols[j],at_symbols[l],gettors(coordinates[k],coordinates[i],coordinates[j],coordinates[l])


        # start building features
        for i in range(len(coordinates)):
            if at_symbols[i]=="H":
                 for j in neighbors[i]:
                    if at_symbols[j]=="C":
                        # 1JHC
						GetNeigborsCount(j,at_symbols, coordinates, neighbors)
						Get2ndLevelNeigborsCount(j, at_symbols, coordinates, neighbors)
						GetNeigborsDistances(j, at_symbols, coordinates, neighbors)
						GetNeigborsAngles(i,j,at_symbols, coordinates, neighbors)
						GetNeigborsTorsions(i,j,at_symbols, coordinates, neighbors)


    structfile.close()
    return

def main():
    '''
    #===============================================================================
    #                               MAIN MAIN MAIN MAIN
    #===============================================================================
    '''
    
    (options,args)=parsecmd()
    
    infile=args[0]
    outfiles=[]
    #tasklist contain the list of task.the list in the 1st element is
    #for the distances, that in the 2nd is for angle and in the 3rd for torsions
    tasklist=[]
        
    fformat=options.fformat     #get format input file
            
    if options.periodicity:   #get periodicity
        pbc=options.periodicity
    else:
        pbc=None

    if options.filedata: #read data from file
        filedata=safeopen(options.filedata,'r')
        if filedata:
            (tasklist,outfiles)=read_filedata(filedata)
        else:
            print "Cannot find "+options.filedata
    else:
        if options.distance: #distance
            junk=[]
            junk.append(list(options.distance)) #convert the tuple from the cml to a list
            tasklist.append(junk)
            tasklist.append(None) #no angle to calculate
            tasklist.append(None) #no torsion to calculate
            #create list outfiles in the form [['file'],None,None]
            outfiles.append('distcml.dat')
            outfiles.append(None)
            outfiles.append(None)
        elif options.angle: #angle
            tasklist.append(None) #no distance to calculate
            junk=[]
            junk.append(list(options.angle)) #convert the tuple from the cml to a list
            tasklist.append(junk)
            tasklist.append(None) #no torsion to calculate
            outfiles.append(None)
            outfiles.append('angcml.dat')
            outfiles.append(None)
        elif options.torsion: #torsion
            tasklist.append(None) #no distance to calculate
            tasklist.append(None) #no angle to calculate
            junk=[]
            junk.append(list(options.torsion)) #convert the tuple from the cml to a list
            tasklist.append(junk)
            outfiles.append(None)
            outfiles.append(None)
            outfiles.append('torscml.dat')
    
    # run calculation
    run(infile,tasklist,fformat,outfiles,pbc)
    return


if __name__ == "__main__":
    main()
    exit(0)


